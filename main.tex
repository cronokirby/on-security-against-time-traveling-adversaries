\include{preamble.tex}

\date{\today}
\title{On Security Against Time Traveling Adversaries}
\author{Lúcás Críostóir Meier\\\texttt{lucas@cronokirby.com}}

\begin{document}

\maketitle

\begin{abstract}
    \noindent In this work, we investigate the notion of
    time travel, formally defining a model for adversaries
    equipped with a time machine, and the subsequent consequences
    on common cryptographic schemes.
\end{abstract}

\section{Introduction}

\cite{maurer_unifying_2009}

\section{Defining Abstract Games}

In this section, we develop a framework to abstract over essentially all
security games used to define the standalone security of cryptographic schemes.

We need such an abstraction in order to explore and compare different models
of time travel.
By having an abstract game, we can more easily define what it means to augment
an adversary with the ability to travel through time, and we can more easily
compare the differences between models of time travel across \emph{all}
games, rather than for just a particular cryptographic scheme.

\subsection{State-Separable Proofs}

But first, we need a basic notion of standalone security.
For this, we lean on the framework of \emph{state-separable proofs}
\todo{cite}.

In this framework, you start with \emph{packages}.
A package $P$ is defined by its code.
This codes describes how to initialize the state of the package, 
and what functions the package exports.
These exported functions are denoted by the set $\text{out}(P)$.
Each of these functions can accept input, produce output, and read and write
to the internal state of the package.
Packages may also have a set of imported functions, denoted by $\text{in}(P)$.

These imported functions are just ``placeholders'', with no semantics.
For them to have meaning, the package needs to be \emph{linked} with another package.
If $A$ and $B$ are packages such that $\text{in}(A) \subseteq \text{out}(B)$,
then we can define the composition package $A \circ B$.
The exports are that of $A$, with $\text{out}(A \circ B) = \text{out}(A)$,
and the imports that of $B$, with $\text{in}(A \circ B) = \text{in}(B)$.
This package is implemented by merging the states of $A$ and $B$, and replacing
calls to the functions in $\text{in}(A)$ with the functionality defined in $B$.

A \emph{game} $G$ is a package with
$\text{in}(G) = \emptyset$.

An \emph{adversary} $\mathcal{A}$ is a package with $\text{out}(\mathcal{A}) = \{\texttt{guess}\}$.
The function $\texttt{guess}$ takes no input, and returns a single bit $\hat{b}$.
This bit represents the adversary's guess as to which of two games it's playing.
Furthermore, if the function $\texttt{guess}$ has a time complexity polynomial
in a security parameter $\lambda$, we say that the adversary is \emph{efficient}.
Most commonly, we assume that all adversaries are efficient, unless we explicitly
mark an adversary as \emph{unbounded}.

By linking an adversary with a game, we get a package $\mathcal{A} \circ G$
with no imports, and a single export $\texttt{guess}$.
This allows us to define the advantage of an adversary $\mathcal{A}$
in distinguishing two games $G_0, G_1$, via the formula:

$$
\epsilon(\mathcal{A} \circ G_b) := \left|P[1 \gets \texttt{guess}()\ |\ b = 0] - P[1 \gets \texttt{guess}() \ |\ b = 1]\right|
$$

Given we a pair of games $G_0, G_1$, we say that they are:

\begin{itemize}
    \item \emph{equal}, denoted by $G_0 = G_1$, when $\epsilon(\mathcal{A} \circ G_b) = 0$ for any adversary, even unbounded.
    \item \emph{indistinguishable}, denoted by $G_0 \approx G_1$, when $\epsilon(\mathcal{A} \circ G_b)$ is a negligeable function of $\lambda$, for any \emph{efficient} adversary (in $\lambda$).
\end{itemize}

The security of a cryptographic scheme is defined by a pair of games $G_b$.
We say that the scheme is \emph{secure} if $G_0 \approx G_1$.

For reductions, given game pairs $G_b$ and $H_b^1, \ldots, H_b^N$,
and a function $p$, we write:

$$
G_b \leq p(H_b^1, \ldots, H_b^n)
$$

If for any efficient adversary $\mathcal{A}$ against $G_b$, there exists efficient
adversaries $\mathcal{B}_1, \ldots, \mathcal{B}_n$ such that:

$$
\epsilon(\mathcal{A} \circ G_b) \leq p(\epsilon(\mathcal{B}_1 \circ H_b^1), \ldots, \epsilon(\mathcal{B}_n \circ H_b^n))
$$

\subsection{Abstract Games}

In the formalism of state-separable proofs, each game can have a different interface,
and maintain a different kind of state.
This is very useful, since it allows us to capture various cryptographic schemes
and notions of security.
However, in order to easily model the impacts of time travel on various games,
we would rather work with a \emph{single} interface, capable of capturing the behavior
of various games and their notions of security.

The key observation here is that the state of a pair of game is modified in only two places:

\begin{enumerate}
    \item When the state is initialized.
    \item When an exported function is called.
\end{enumerate}

We can also collapse all of the exported functions into a single function,
by including additional information in the input.
For example, the input can include which sub-function is being called,
along with the arguments to that sub-function.

The data we need to describe a game thus consist of a set of states
$\Sigma$, an initialization function $\texttt{init} : () \xrightarrow{R} \Sigma$,
as well as input and output types $X$ and $Y$, along with
a transition function ${\texttt{next} : X \times \Sigma \to Y \times \Sigma}$.

Together, these data define the following game:

\begin{game}
\captionsetup{justification=centering}
$$
\boxed{
\begin{aligned}
&\colorbox{pink}{\large $\mathcal{G}(\texttt{init}, \texttt{next})$}\cr
&s \gets \texttt{init}()\cr
&\underline{\mathcal{O}(x):}\cr
&\ s, y \gets \texttt{next}(s, x)\cr
&\ \texttt{return } y
\end{aligned}
}
$$
\caption{$\mathcal{G}(\texttt{init}, \texttt{next})$}
\end{game}

Intuitively, the game uses $\texttt{init}$ to randomly initialize the state, and
then each subsequent oracle call triggers some kind of randomized calculation
which modifies the state, and produces an output.

We can also implicitly parameterize the types and functions with a bit $b$,
allowing us to define the game pair $\mathcal{G}_b(\texttt{init}, \texttt{next})$,
which is shorthand for $\mathcal{G}(\texttt{init}_b, \texttt{next}_b)$.

This abstract game is simple, but still expressive enough to capture any
kind of game expressable in the state-separable formalism.

\section{Models of Time Travel}

In this section we investigate various models of time travel, and compare
them with each other, showing that they form a hierarchy of increasingly
strong capabilities.

The notion of time travel we explore is an intuitive one, inspired by
science fiction.
The adversary is equipped with a time machine, which allows them
to travel forwards and backwards in time.
However, the adversary must still be \emph{efficient}.
From their point of view, they only perform a number of operations
polynomial in the security parameter $\lambda$, including time travel
hops.

Some other models of time travel, like closed timelike curves, would allow,
in essence, for computation with unbounded time (but bounded space) by an adversary.
This is a much more powerful capability than we consider in this work,
and unbounded computation breaks essentially all cryptography beyond
information-theoretic schemes.

We also assume that time is \emph{discrete}.
Each interaction the adversary has with a game advances time forward
by one step, and time hops can only be made between these discrete points
in time.
One potentially stronger capability would be to allow an adversary
to ``partially'' undo the effects of an interaction, by rewinding
an interaction before its completion.
The reason we disallow this is because we assume the adversary has
no other channels to learn about the state of the game beyond the
information it gets from querying its exported functions.
An adversary thus has no way of knowing where they need to time hop
in order to partially undo an interaction, so we can make the simplifying
assumption that all interactions are \emph{atomic}, and time is discrete.

\subsection{Rewinding Models}

The first model of time travel we consider is that of \emph{rewinding},
in which the adversary is allowed to travel backwards in time.

\subsubsection{Single Rewinds}

We start by giving the adversary the ability to travel backwards
by exactly one time step.

We model this as a \emph{transformation} between games.
Given an abstract game $\mathcal{G}_b$, we define the game
$\text{Rewind-1}(\mathcal{G}_b)$ as follows:

\begin{game}
\captionsetup{justification=centering}
$$
\boxed{
\begin{aligned}
&\colorbox{pink}{\large $\text{Rewind-1}(\mathcal{G}_b)$}\cr
&s_0 \gets \texttt{init}()\cr
&i \gets 0\cr
&\begin{aligned}
    &\underline{\mathcal{O}(x):}\cr
    &s_{i + 1}, y \gets \texttt{next}(s_i, x)\cr
    &\texttt{return } y\cr
\end{aligned}
&\begin{aligned}
    &\underline{\texttt{Rewind}():}\cr
    &\texttt{assert } i > 0\cr
    &i \gets i - 1\cr
\end{aligned}\cr
\end{aligned}
}
$$
\caption{$\text{Rewind-1}(\mathcal{G}_b)$}
\end{game}

The interface is the same as that of $\mathcal{G}_b$, except that
we now have an additional exported function: $\texttt{Rewind}$.
Apart from this function, the behavior of the game is the same.
Each interaction with $\mathcal{O}$ advances the state.
The difference is only in the internal implementation.
Instead of a single state $s$, we now have a sequence of states
$s_0, s_1, \ldots$, as well as a position in this sequence, $i$.

The $\texttt{Rewind}$ function is the additional capability here,
and allows the adversary to move backwards by one step in time.
This essentially models a very limited time machine, only
allowing a small backwards movement in time.

Our first question is: does this limited model of time travel help
the adversary?
In other words, is an adversary with this capability more powerful
than adversary without it? 
One way of capturing this notion of power would be to demonstrate
a game $\mathcal{E}_b$ which is \emph{secure}, but where
$\text{Rewind-1}(\mathcal{E}_b)$ is broken.
In fact, we can do this:

\begin{claim}
    \label{claim:rewind-1-is-stronger}
    There exists a game $\mathcal{E}_b$ and adversary $\mathcal{A}$ such that 
    $\mathcal{E}_b$ is secure, yet $\epsilon(\mathcal{A} \circ \text{Rewind-1}(\mathcal{E}_b)) = 1$.
\end{claim}

Consider the following game:

\begin{game}
\captionsetup{justification=centering}
$$
\boxed{
\begin{aligned}
&\colorbox{pink}{\large $\mathcal{E}_b$}\cr
&k_0, k_1 \xleftarrow{R} \{0, 1\}^\lambda\cr
&\text{queried} \gets 0\cr
&\begin{aligned}
    &\underline{\texttt{Query}(\sigma):}\cr
    &\texttt{assert } \text{queried} = 0\cr
    &\text{queried} \gets 1\cr
    &\texttt{return } k_\sigma\cr
\end{aligned}
&\begin{aligned}
    &\underline{\texttt{Guess}(\hat{k}_0, \hat{k}_1):}\cr
    &\texttt{assert } \hat{k}_0 = k_0 \land \hat{k}_1 = k_1\cr
    &\texttt{return } b\cr
    &\cr
\end{aligned}\cr
\end{aligned}
}
$$
\end{game}

In this game, we have two random keys $k_0, k_1$.
The game lets the adversary choose to learn one of the keys, but not
the other.
If the adversary manages to guess both of the keys, then they'll be
able to learn the value of $b$.

Now, because $k_\sigma$ has $\lambda$ bits, an adversary won't be able
to randomly guess its value.
This means that if the adversary only knows one of the keys, they won't
be able to pass the assertion except with negligeable probability.
This means that $\mathcal{E}_b$ is secure.

On the other hand, $\text{Rewind-1}(\mathcal{E}_b)$ is already broken.
The following strategy will always succeed:

$$
\begin{aligned}
&k_0 \gets \texttt{Query}(0)\cr
&\texttt{Rewind}()\cr
&k_1 \gets \texttt{Query}(1)\cr
&b \gets \texttt{Guess}(k_0, k_1)\cr
&\texttt{return } b\cr
\end{aligned}
$$

Even though the adversary prevents us from querying more than once,
a single rewinding step is enough to undo our query, and thus learn
the other key.

$\blacksquare$

\subsubsection{Multiple Rewinds}

Next, we consider the ability to travel backwards by multiple steps
at once.
Like before, we model this with another transformation:
$\text{Rewind-Many}$.

\begin{game}
\captionsetup{justification=centering}
$$
\boxed{
\begin{aligned}
&\colorbox{pink}{\large $\text{Rewind-Many}(\mathcal{G}_b)$}\cr
&s_0 \gets \texttt{init}()\cr
&i \gets 0\cr
&\begin{aligned}
    &\underline{\mathcal{O}(x):}\cr
    &s_{i + 1}, y \gets \texttt{next}(s_i, x)\cr
    &\texttt{return } y\cr
\end{aligned}
&\begin{aligned}
    &\underline{\texttt{Rewind}(j):}\cr
    &\texttt{assert } i >= j\cr
    &i \gets i - j\cr
\end{aligned}\cr
\end{aligned}
}
$$
\caption{$\text{Rewind-Many}(\mathcal{G}_b)$}
\end{game}

The only difference with $\text{Rewind-1}$ is that now the adversary
can specify a hop distance $j$, and move backwards by $j$ steps,
rather than by just a single step.

A natural question arises: is being able to jump backwards multiple
steps at a time more powerful?

No.

\begin{claim}
    \label{claim:rewind-many-is-not-strong}
    $\text{Rewind-Many}$ is as strong as $\text{Rewind-1}$.
    In particular, for any abstract game $\mathcal{G}_b$, we have
    $\text{Rewind-Many}(\mathcal{G}_b) \leq \text{Rewind-1}(\mathcal{G}_b)$.
\end{claim}

The reduction works by emulating a large jump with many tiny jumps.

$$
\text{Rewind-Many}(\mathcal{G}_b) =
\boxed{
\begin{aligned}
&\colorbox{pink}{\large $\Gamma$}\cr
&\begin{aligned}
    &\underline{\mathcal{O}(x):}\cr
    &\texttt{return } \texttt{super}.\mathcal{O}(x)\cr
\end{aligned}
&\begin{aligned}
    &\underline{\texttt{Rewind}(j):}\cr
    &\texttt{assert } i >= j\cr
    &\texttt{super}.\texttt{Rewind}()\ j \text{ times }\cr
\end{aligned}\cr
\end{aligned}
}
\ \circ\ 
\text{Rewind-1}(\mathcal{G}_b)
$$

The only subtlety is that we need to guarantee that this emulation
is efficient, i.e. polynomial in $\lambda$.
Because the adversary for $\mathcal{A}$ against $\text{Rewind-Many}(\mathcal{G}_b)$
is efficient, we know that they make a number of queries to $\mathcal{O}$ polynomial
in $\lambda$.
This means that the largest $i$ they reach is also bounded, and thus so will the largest
$j$ they query.
This means that the number of iterations we do in the emulation is also bounded by a polynomial
in $\lambda$, so the reduction is efficient.

$\blacksquare$



\subsection{Forking Models}

\subsection{Summary}

\section{On Depth and Position Restrictions}

\section{Effects of Time Travel on Common Schemes}

\subsection{Stateless Schemes Remain Secure}

\subsection{On Encryption}

\subsection{On Signatures}

\section{Further Work}

\section{Conclusion}

\bibliographystyle{alpha}
\small \bibliography{bib}
\end{document}
